//go:build !ignore_autogenerated
// +build !ignore_autogenerated

// SPDX-FileCopyrightText: SAP SE or an SAP affiliate company and Gardener contributors
//
// SPDX-License-Identifier: Apache-2.0
// Code generated by deepcopy-gen. DO NOT EDIT.

package v1alpha1

import (
	corev1 "k8s.io/api/core/v1"
	resource "k8s.io/apimachinery/pkg/api/resource"
	v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	runtime "k8s.io/apimachinery/pkg/runtime"
)

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *BackoffPolicy) DeepCopyInto(out *BackoffPolicy) {
	*out = *in
	out.InitialBackoffDuration = in.InitialBackoffDuration
	out.MaxBackoffDuration = in.MaxBackoffDuration
	return
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new BackoffPolicy.
func (in *BackoffPolicy) DeepCopy() *BackoffPolicy {
	if in == nil {
		return nil
	}
	out := new(BackoffPolicy)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ClusterScalingAdvice) DeepCopyInto(out *ClusterScalingAdvice) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
	return
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ClusterScalingAdvice.
func (in *ClusterScalingAdvice) DeepCopy() *ClusterScalingAdvice {
	if in == nil {
		return nil
	}
	out := new(ClusterScalingAdvice)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *ClusterScalingAdvice) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ClusterScalingAdviceList) DeepCopyInto(out *ClusterScalingAdviceList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]ClusterScalingAdvice, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	return
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ClusterScalingAdviceList.
func (in *ClusterScalingAdviceList) DeepCopy() *ClusterScalingAdviceList {
	if in == nil {
		return nil
	}
	out := new(ClusterScalingAdviceList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *ClusterScalingAdviceList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ClusterScalingAdviceSpec) DeepCopyInto(out *ClusterScalingAdviceSpec) {
	*out = *in
	if in.ScaleOutPlan != nil {
		in, out := &in.ScaleOutPlan, &out.ScaleOutPlan
		*out = new(ScaleOutPlan)
		(*in).DeepCopyInto(*out)
	}
	if in.ScaleInPlan != nil {
		in, out := &in.ScaleInPlan, &out.ScaleInPlan
		*out = new(ScaleInPlan)
		(*in).DeepCopyInto(*out)
	}
	return
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ClusterScalingAdviceSpec.
func (in *ClusterScalingAdviceSpec) DeepCopy() *ClusterScalingAdviceSpec {
	if in == nil {
		return nil
	}
	out := new(ClusterScalingAdviceSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ClusterScalingAdviceStatus) DeepCopyInto(out *ClusterScalingAdviceStatus) {
	*out = *in
	if in.Backoffs != nil {
		in, out := &in.Backoffs, &out.Backoffs
		*out = make([]ZoneInstanceTypeBackoff, len(*in))
		copy(*out, *in)
	}
	return
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ClusterScalingAdviceStatus.
func (in *ClusterScalingAdviceStatus) DeepCopy() *ClusterScalingAdviceStatus {
	if in == nil {
		return nil
	}
	out := new(ClusterScalingAdviceStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ClusterScalingConstraint) DeepCopyInto(out *ClusterScalingConstraint) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
	return
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ClusterScalingConstraint.
func (in *ClusterScalingConstraint) DeepCopy() *ClusterScalingConstraint {
	if in == nil {
		return nil
	}
	out := new(ClusterScalingConstraint)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *ClusterScalingConstraint) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ClusterScalingConstraintList) DeepCopyInto(out *ClusterScalingConstraintList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]ClusterScalingConstraint, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	return
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ClusterScalingConstraintList.
func (in *ClusterScalingConstraintList) DeepCopy() *ClusterScalingConstraintList {
	if in == nil {
		return nil
	}
	out := new(ClusterScalingConstraintList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *ClusterScalingConstraintList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ClusterScalingConstraintSpec) DeepCopyInto(out *ClusterScalingConstraintSpec) {
	*out = *in
	if in.NodePools != nil {
		in, out := &in.NodePools, &out.NodePools
		*out = make([]NodePool, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.InstancePricing != nil {
		in, out := &in.InstancePricing, &out.InstancePricing
		*out = make([]InstancePricing, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.BackoffPolicy != nil {
		in, out := &in.BackoffPolicy, &out.BackoffPolicy
		*out = new(BackoffPolicy)
		**out = **in
	}
	if in.ScaleInPolicy != nil {
		in, out := &in.ScaleInPolicy, &out.ScaleInPolicy
		*out = new(ScaleInPolicy)
		**out = **in
	}
	return
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ClusterScalingConstraintSpec.
func (in *ClusterScalingConstraintSpec) DeepCopy() *ClusterScalingConstraintSpec {
	if in == nil {
		return nil
	}
	out := new(ClusterScalingConstraintSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ClusterScalingConstraintStatus) DeepCopyInto(out *ClusterScalingConstraintStatus) {
	*out = *in
	if in.Conditions != nil {
		in, out := &in.Conditions, &out.Conditions
		*out = make([]v1.Condition, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	return
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ClusterScalingConstraintStatus.
func (in *ClusterScalingConstraintStatus) DeepCopy() *ClusterScalingConstraintStatus {
	if in == nil {
		return nil
	}
	out := new(ClusterScalingConstraintStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *InstancePricing) DeepCopyInto(out *InstancePricing) {
	*out = *in
	if in.UnitCPUPrice != nil {
		in, out := &in.UnitCPUPrice, &out.UnitCPUPrice
		*out = new(float64)
		**out = **in
	}
	if in.UnitMemoryPrice != nil {
		in, out := &in.UnitMemoryPrice, &out.UnitMemoryPrice
		*out = new(float64)
		**out = **in
	}
	return
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new InstancePricing.
func (in *InstancePricing) DeepCopy() *InstancePricing {
	if in == nil {
		return nil
	}
	out := new(InstancePricing)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *NodePool) DeepCopyInto(out *NodePool) {
	*out = *in
	if in.Labels != nil {
		in, out := &in.Labels, &out.Labels
		*out = make(map[string]string, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.Annotations != nil {
		in, out := &in.Annotations, &out.Annotations
		*out = make(map[string]string, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.Taints != nil {
		in, out := &in.Taints, &out.Taints
		*out = make([]corev1.Taint, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.AvailabilityZones != nil {
		in, out := &in.AvailabilityZones, &out.AvailabilityZones
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
	if in.NodeTemplates != nil {
		in, out := &in.NodeTemplates, &out.NodeTemplates
		*out = make([]NodeTemplate, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Quota != nil {
		in, out := &in.Quota, &out.Quota
		*out = make(corev1.ResourceList, len(*in))
		for key, val := range *in {
			(*out)[key] = val.DeepCopy()
		}
	}
	if in.ScaleInPolicy != nil {
		in, out := &in.ScaleInPolicy, &out.ScaleInPolicy
		*out = new(ScaleInPolicy)
		**out = **in
	}
	return
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new NodePool.
func (in *NodePool) DeepCopy() *NodePool {
	if in == nil {
		return nil
	}
	out := new(NodePool)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *NodeTemplate) DeepCopyInto(out *NodeTemplate) {
	*out = *in
	if in.Capacity != nil {
		in, out := &in.Capacity, &out.Capacity
		*out = make(corev1.ResourceList, len(*in))
		for key, val := range *in {
			(*out)[key] = val.DeepCopy()
		}
	}
	if in.KubeReserved != nil {
		in, out := &in.KubeReserved, &out.KubeReserved
		*out = new(corev1.ResourceList)
		if **in != nil {
			in, out := *in, *out
			*out = make(map[corev1.ResourceName]resource.Quantity, len(*in))
			for key, val := range *in {
				(*out)[key] = val.DeepCopy()
			}
		}
	}
	if in.SystemReserved != nil {
		in, out := &in.SystemReserved, &out.SystemReserved
		*out = new(corev1.ResourceList)
		if **in != nil {
			in, out := *in, *out
			*out = make(map[corev1.ResourceName]resource.Quantity, len(*in))
			for key, val := range *in {
				(*out)[key] = val.DeepCopy()
			}
		}
	}
	if in.EvictionThreshold != nil {
		in, out := &in.EvictionThreshold, &out.EvictionThreshold
		*out = new(corev1.ResourceList)
		if **in != nil {
			in, out := *in, *out
			*out = make(map[corev1.ResourceName]resource.Quantity, len(*in))
			for key, val := range *in {
				(*out)[key] = val.DeepCopy()
			}
		}
	}
	return
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new NodeTemplate.
func (in *NodeTemplate) DeepCopy() *NodeTemplate {
	if in == nil {
		return nil
	}
	out := new(NodeTemplate)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ScaleInPlan) DeepCopyInto(out *ScaleInPlan) {
	*out = *in
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]ScaleItem, len(*in))
		copy(*out, *in)
	}
	if in.NodeNames != nil {
		in, out := &in.NodeNames, &out.NodeNames
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
	return
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ScaleInPlan.
func (in *ScaleInPlan) DeepCopy() *ScaleInPlan {
	if in == nil {
		return nil
	}
	out := new(ScaleInPlan)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ScaleInPolicy) DeepCopyInto(out *ScaleInPolicy) {
	*out = *in
	return
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ScaleInPolicy.
func (in *ScaleInPolicy) DeepCopy() *ScaleInPolicy {
	if in == nil {
		return nil
	}
	out := new(ScaleInPolicy)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ScaleItem) DeepCopyInto(out *ScaleItem) {
	*out = *in
	return
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ScaleItem.
func (in *ScaleItem) DeepCopy() *ScaleItem {
	if in == nil {
		return nil
	}
	out := new(ScaleItem)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ScaleOutPlan) DeepCopyInto(out *ScaleOutPlan) {
	*out = *in
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]ScaleItem, len(*in))
		copy(*out, *in)
	}
	return
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ScaleOutPlan.
func (in *ScaleOutPlan) DeepCopy() *ScaleOutPlan {
	if in == nil {
		return nil
	}
	out := new(ScaleOutPlan)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ZoneInstanceTypeBackoff) DeepCopyInto(out *ZoneInstanceTypeBackoff) {
	*out = *in
	return
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ZoneInstanceTypeBackoff.
func (in *ZoneInstanceTypeBackoff) DeepCopy() *ZoneInstanceTypeBackoff {
	if in == nil {
		return nil
	}
	out := new(ZoneInstanceTypeBackoff)
	in.DeepCopyInto(out)
	return out
}
